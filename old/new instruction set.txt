### Arithmetic instruction

15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
 M S3 S2 S1 S0 Cn Sw|  Test  |
  (ALU operation)  -|        |

Opcode format: M S3 S2 S1 S0 Cn SwapBytes
Tests: Always, Carry, Zero, Minus1, Never, NC, NZ, NM1
Operations with literal argument: Call, Branch, Push Data, Push Return
Operations without argument: Return, Skip, Load*, Store*, Return from Int.

### Call

15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
(    Most significant 15 bits of address   )  0

### Load/store

15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
Wr AddrR DataR ++ TN

Address Reg: Top, PC, DSP, RSP
Data Reg:    Top, Next, PC, IR
TN: If Wr, Top -> Next / if Rd, Next <- Top


Top from: Top, Next, ALU, Data Bus, Pop(DS), Pop(RS), Load(PC), Load(Top)
Next from: Top, Next, ALU, Data Bus, Pop(DS), Pop(RS)

##### Arithmetic
Data  = ALU output
Top  <= Top, Next, Data
Next <= Top, Next, Data

#### Load (7 bits)
Data  = Mem(DSP), Mem(RSP), Mem(PC), Mem(Top)
Top  <= Top, Next, Data
Next <= Top, Next, Data
Increment address pointer?

#### Store (5 bits)
Data = Top, Next, PC
Data => Mem(DSP), Mem(RSP), Mem(PC), Mem(Top)
Increment address pointer?